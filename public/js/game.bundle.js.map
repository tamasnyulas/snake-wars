{"version":3,"file":"game.bundle.js","mappings":";;;;;;;;;;;;;;;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA,gBAAgB,OAAO;AACvB,sEAAsE;;AAEtE,+DAA+D;AAC/D;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV,KAAK;;AAEL;AACA;AACA;AACA;AACA,iBAAiB;AACjB,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;;;;;;;;;;;;;;;;ACpDmC;AACA;AACQ;;AAEpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAS;AACxB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,4CAAK;AACjB,YAAY,4CAAK;;AAEjB;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA,yCAAyC;AACzC,SAAS;;AAET;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA,yCAAyC,oDAAS;;AAElD,YAAY,4CAAK;AACjB,SAAS;;AAET;AACA;AACA;AACA;AACA,iEAAiE,uEAAuE;AACxI;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,yBAAyB,oDAAS;AAClC;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,YAAY,4CAAK;AACjB;;AAEA;AACA,YAAY,4CAAK;AACjB;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yCAAyC,oDAAS;AAClD;AACA,gCAAgC,WAAW;AAC3C;;AAEA;AACA,mCAAmC,SAAS,WAAW,mBAAmB;AAC1E;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;;;;;;;;;;;;;;AC/MO;AACP;AACA;AACA;AACA;;AAEA,gCAAgC;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpEO;AACP,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA,sCAAsC;;AAEtC;;AAEA;AACA;;AAEA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;;AAEb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA,2CAA2C,oBAAoB;AAC/D,UAAU;AACV;AACA,2CAA2C,iBAAiB;AAC5D,UAAU;AACV;AACA,2CAA2C,mBAAmB;AAC9D,UAAU;AACV;AACA,2CAA2C,mBAAmB;AAC9D;AACA,KAAK;AACL;;;;;;;UC7KA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;ACN6C;;AAE7C;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL,IAAI,sDAAU;AACd,CAAC","sources":["webpack://snake-wars/./src/client/Apple.js","webpack://snake-wars/./src/client/GameClient.js","webpack://snake-wars/./src/client/GameState.js","webpack://snake-wars/./src/client/Snake.js","webpack://snake-wars/webpack/bootstrap","webpack://snake-wars/webpack/runtime/define property getters","webpack://snake-wars/webpack/runtime/hasOwnProperty shorthand","webpack://snake-wars/webpack/runtime/make namespace object","webpack://snake-wars/./src/client/game.entry.js"],"sourcesContent":["\nexport const Apple = {\n    canvas: null,\n\n    initialize: function (width, height, canvasContainer) {\n        this.canvas = document.createElement('canvas');\n        canvasContainer.appendChild(this.canvas);\n        this.canvas.width = width;\n        this.canvas.height = height;\n    },\n\n    renderApple: function (appleInstance, gridSize) {\n        const canvasContext = this.canvas.getContext('2d');\n\n        canvasContext.clearRect(0, 0, canvasContext.canvas.width, canvasContext.canvas.height);\n        canvasContext.beginPath();\n\n        const { x, y } = this.getCoordinatesFromIndex(appleInstance.position, gridSize);\n        canvasContext.fillStyle = this.getColor(appleInstance.value); // TODO: use appleInstance.color & speedBomb style\n\n        canvasContext.arc(x + 10, y + 10, 10, 0, 2 * Math.PI); // TODO: use snakeUnit to calculate the radius\n        canvasContext.fill();\n        canvasContext.closePath();\n\n        /*grid[appleInstance.position].classList.add(\n            \"apple\",\n            appleInstance.color,\n            appleInstance.speedBomb ? \"speedBomb\" : null\n        );*/\n    },\n\n    // TODO: move this to an abstract class and reuse it for Apple and Snake respectively\n    getCoordinatesFromIndex: function(index, gridSize) {\n        const x = (index % gridSize) * 20;\n        const y = Math.floor(index / gridSize) * 20;\n        return { x, y };\n    },\n\n    getColor: function(value) {\n        switch (value) {\n            case 1:\n                return \"rgb(0, 255, 85)\";\n            case 2:\n                return \"rgb(0, 89, 255)\";\n            case 3:\n                return \"rgb(153, 0, 255)\";\n            case 4:\n                return \"rgb(237, 181, 14)\";\n            case 5:\n                return \"rgb(255, 0, 140)\";\n        }\n    },\n};\n","import { Snake } from './Snake.js';\nimport { Apple } from './Apple.js';\nimport { GameState } from './GameState.js';\n\nexport const GameClient = {\n    canvasContainer: document.querySelector(\".canvasContainer\"),\n    touchControlPanel: document.querySelector(\".touchControlPanel\"),\n    popup: document.querySelector(\".popup\"),\n    joinGameForm: document.querySelector(\".joinGameForm\"),\n    usernameInput: document.querySelector(\"input[name='username']\"),\n    btnReadyCheck: document.querySelector(\".readyCheck\"),\n    scoreDisplay: document.querySelector(\".scoreDisplay\"),\n    isTouchScreen: 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0,\n    socket: null,\n    settings: null,\n    state: new GameState(),\n    snakeUnit: 20,\n\n    initialize: function (socket) {\n        this.socket = socket;\n\n        // Set up client event listeners\n        socket.on('connected', (response) => {\n            console.log('connected', response);\n            this.settings = response.settings;\n            Snake.initialize(this.settings.columns, this.settings.columns * this.snakeUnit, this.settings.rows * this.snakeUnit, this.canvasContainer);\n            Apple.initialize(this.settings.columns * this.snakeUnit, this.settings.rows * this.snakeUnit, this.canvasContainer);\n\n            this.createBoard();\n            this.syncState(response.state);\n\n            // MVP\n            this.checkJoin();\n        });\n\n        socket.on('disconnect', () => {\n            console.log('disconnected'); // TODO: handle disconnect\n        });\n\n        socket.on('sync-state', (state) => this.syncState(state));\n\n        socket.on('sync-state-diff', (stateDiff) => this.syncStateDiff(stateDiff));\n\n        socket.on('start-game', (state) => {\n            console.log('The game is starting');\n            this.createBoard();\n            this.syncState(state);\n        });\n\n        socket.on('end-game', (state) => {\n            console.log('The game is ending');\n            this.syncState(state);\n            this.endGame();\n        });\n\n        this.bindControlEventListeners();\n    },\n\n    bindControlEventListeners: function () {\n        this.joinGameForm.addEventListener(\"submit\", this.joinGame.bind(this));\n        this.btnReadyCheck.addEventListener(\"click\", this.readyCheck.bind(this));\n\n        // TODO: ensure that non-players can't control the game\n        document.addEventListener(\"keydown\", (e) => {\n            if (this.state.stateName !== GameState.STATE_NAME.PLAYING) return;\n\n            Snake.control(e, this.state.snakes[this.socket.id], this.settings.columns, this.socket);\n        });\n\n        if (this.isTouchScreen) {\n            [\"up\", \"down\", \"left\", \"right\"].forEach(direction => {\n                const button = document.querySelector(\".\" + direction);\n                button.addEventListener(\"click\", () => {\n                    const event = new KeyboardEvent(\"keydown\", { key: \"Arrow\" + direction.charAt(0).toUpperCase() + direction.slice(1) });\n                    document.dispatchEvent(event);\n                });\n            });\n        }\n    },\n\n    // TODO: This should be called when a user joins or leaves the game\n    checkJoin: function () {\n        const canJoin = (Object.keys(this.state.snakes).length < this.settings.players);\n        this.joinGameForm.style.display = canJoin ? \"inline-block\" : \"none\";\n        if (canJoin) {\n            this.usernameInput.focus();\n        }\n    },\n\n    joinGame: function (e) {\n        e.preventDefault();\n\n        if (!this.usernameInput.checkValidity()) {\n            this.usernameInput.reportValidity();\n            return;\n        } \n\n        const preferences = {\n            username: this.usernameInput.value,\n        };\n        \n        const joinPromise = (async (preferences) => {\n            console.log('joining game', preferences);\n            return await this.socket.emitWithAck('join-game', preferences);\n        })(preferences);\n\n        joinPromise.then(response => {\n            if (response.isSuccess === false) {\n                console.log('Join failed:', response.error);\n                return;\n            }\n\n            // Handle successful response\n            this.joinGameForm.style.display = \"none\";\n            this.btnReadyCheck.style.display = \"inline-block\";\n            this.btnReadyCheck.focus();\n            \n            if (this.isTouchScreen) {\n                this.touchControlPanel.style.display = \"block\";\n            }\n        })\n        .catch(error => {\n            // Handle error\n            console.error('Join error:', error);\n        });\n    },\n\n    readyCheck: function () {\n        this.socket.emit('ready-check', true);\n\n        this.btnReadyCheck.style.display = \"none\";\n    },\n\n    // TODO: There's a glitch regarding the snake tail rendering on the initial position\n    createBoard: function () {\n        this.canvasContainer.style.width = this.settings.columns * this.snakeUnit;\n        this.canvasContainer.style.height = this.settings.rows * this.snakeUnit;\n\n        this.joinGameForm.style.display = \"none\";\n        this.btnReadyCheck.style.display = \"none\";\n    },\n\n    syncState: function (state) {\n        console.log('syncing new state', state);\n        this.state = new GameState(state);\n        this.syncGame();\n    },\n\n    syncStateDiff: function (stateDiff) {\n        console.log('syncing new state diff', stateDiff);\n        this.state.mergeDiff(stateDiff);\n        this.syncGame();\n    },\n\n    syncGame: function () {\n        for (const [id, snakeState] of Object.entries(this.state.snakes)) {\n            Snake.render(snakeState, id, this.settings.columns);\n        };\n\n        if (this.state.apple) {\n            Apple.renderApple(this.state.apple, this.settings.columns);\n        }\n\n        this.refreshScore(false);\n    },\n\n    endGame: function () {\n        if (this.state.snakes[this.socket.id]) {\n            this.btnReadyCheck.style.display = \"inline-block\";\n        } else {\n            this.checkJoin();\n        }\n\n        this.refreshScore(true);\n    },\n\n    refreshScore: function (endGame = false) {\n        let topScore = this.determineTopScore();\n        this.scoreDisplay.innerHTML = \"\";\n\n        Object.values(this.state.snakes).forEach((snake, index) => {\n            const row = document.createElement(\"tr\");\n            row.style.color = snake.color;\n\n            if (endGame && snake.currentScore > 0 && snake.currentScore === topScore) {\n                row.classList.add(\"winner\");\n            }\n\n            let username = encodeURIComponent(snake.username);\n            if (this.state.stateName === GameState.STATE_NAME.WAITING)  {\n                const readyCheck = snake.readyCheck ? \" (ready)\" : \"\";\n                username += ` ${readyCheck}`;\n            }\n\n            // TODO: add color to each name identical to their snakes\n            row.innerHTML = `<th>${username}</th><td>${snake.currentScore}</td>`;\n            this.scoreDisplay.appendChild(row);\n        });\n    },\n\n    determineTopScore: function () {\n        let scores = Object.values(this.state.snakes).map(snake => snake.currentScore);\n        let topScore = Math.max(...scores);\n        \n        return topScore\n    },\n\n};\n","export class GameState {\n    static STATE_NAME = {\n        WAITING: 'waiting',\n        PLAYING: 'playing',\n    };\n\n    constructor(stateValues = {}) {\n        // TODO: consider moving player metadata to a separate place and only keep snake position related info\n        this.snakes = stateValues.snakes || {};\n\n        this.stateName = stateValues.stateName || GameState.STATE_NAME.WAITING;\n        this.apple = stateValues.apple || null;\n        this.activePlayers = stateValues.activePlayers || 0;\n        this.grid = stateValues.grid || [];\n        this.intervalTime = stateValues. intervalTime || 0;\n    }\n\n    reset() {\n        this.stateName = GameState.STATE_NAME.WAITING;\n        this.apple = null;\n        this.activePlayers = 0;\n        this.grid = [];\n        this.intervalTime = 0;\n    }\n\n    mergeDiff(diff) {\n        this.traverseAndSet(this, diff.added);\n        this.traverseAndSet(this, diff.updated);\n        this.deleteProperties(this, diff.deleted);\n    }\n\n    traverseAndSet(obj, diffObj) {\n        if (diffObj === undefined || diffObj === null) return;\n\n        Object.keys(diffObj).forEach(key => {\n            if (typeof diffObj[key] === 'object') {\n                if (!obj[key]) {\n                    obj[key] = {};\n                }\n                this.traverseAndSet(obj[key], diffObj[key]);\n            } else {\n                if (Array.isArray(obj[key])) {\n                    obj[key].splice(parseInt(key), 0, diffObj[key]);\n                } else {\n                    obj[key] = diffObj[key];\n                }\n            }\n        });\n    };\n\n    deleteProperties(target, diffObj) {\n        Object.keys(diffObj).forEach(key => {\n            const value = diffObj[key];\n            if (typeof value === 'object' && value !== null) {\n                this.deleteProperties(target[key], value);\n            } else {\n                this.deleteFromTarget(target, key);\n            }\n        });\n    };\n\n    deleteFromTarget(target, key) {\n        if (Array.isArray(target)) {\n            target.splice(key, 1);\n        } else {\n            delete target[key];\n        }\n    };\n}\n","export const Snake = {\n    directionMap: {},\n    controlKeys: {\n        left: 'ArrowLeft',\n        up: 'ArrowUp',\n        right: 'ArrowRight',\n        down: 'ArrowDown',\n    },\n    canvases: {},\n    canvasWidth: null,\n    canvasHeight: null,\n    canvasContainer: null,\n\n    initialize: function (columns, width, height, canvasContainer) {\n        this.directionMap = {\n            \"1\": \"east\",\n            '-1': \"west\",\n            [columns]: \"south\",\n            [\"-\" + columns]: \"north\",\n        };\n        this.canvasWidth = width;\n        this.canvasHeight = height;\n        this.canvasContainer = canvasContainer;\n    },\n\n    getCanvas: function (id) {\n        if (this.canvases[id]) return this.canvases[id];\n\n        this.canvases[id] = document.createElement('canvas');\n        this.canvasContainer.appendChild(this.canvases[id]);\n        this.canvases[id].width = this.canvasWidth;\n        this.canvases[id].height = this.canvasHeight;\n\n        return this.canvases[id];\n    },\n\n    createSnake: function (options) {\n        const snakeInstance = {\n            ...defaultOptions,\n            ...options,\n            currentPosition: [...options.initialPosition],\n            currentDirection: options.initialDirection,\n            size: options.initialPosition.size,\n            currentScore: 0,\n            growth: 0,\n            canMove: true,\n            username: options.username,\n            color: options.color,\n            reset: function () {\n                this.currentPosition = [...this.initialPosition];\n                this.currentDirection = this.initialDirection;\n                this.size = this.initialPosition.size;\n                this.growth = 0;\n                this.currentScore = 0;\n                this.canMove = true;\n            },\n            score: function (value) {\n                this.growth += value;\n                this.currentScore += value;\n            },\n        };\n\n        return snakeInstance;\n    },\n\n    // TODO: when the game is over, the snakes are still animated for their last moves on state synchronization. This should be fixed.\n    render: function (snakeState, id, gridSize) {\n        if (!snakeState.canMove) return;\n\n        const canvasContext = this.getCanvas(id).getContext('2d');\n\n        let frame = 0;\n        let frames = 200 / 1000 * 60; // 60 frames per second, FIX the hardcoded time (200) according the game speed\n\n        requestAnimationFrame(animate);\n\n        function animate() {\n            canvasContext.clearRect(0, 0, canvasContext.canvas.width, canvasContext.canvas.height);\n\n            snakeState.currentPosition.forEach((index, i) => {\n                \n                const { x: xTo, y: yTo } = getCoordinatesFromIndex(index, gridSize);\n                let params = {\n                    xFrom: xTo,\n                    yFrom: yTo,\n                    xTo: xTo,\n                    yTo: yTo,\n                };\n\n                if (snakeState.previousPosition && snakeState.previousPosition[i] !== undefined) {\n                    const { x: xFrom, y: yFrom  } = getCoordinatesFromIndex(snakeState.previousPosition[i], gridSize);\n                    params.xFrom = xFrom;\n                    params.yFrom = yFrom;\n                }\n                \n                canvasContext.fillStyle = i % 2 === 0 ? '#F5F5F5' : '#CFCFCF'; // FIX the hardcoded color\n                drawSnakePart(params);\n\n                /*let snakePart = i === 0 ? \"head\" : i === snakeState.currentPosition.length - 1 ? \"tail\" : \"body\";\n                \n                grid[index].classList.add(\"snake\", snakePart);\n                grid[index].classList.remove(\"apple\");\n                grid[index].style.backgroundColor = snakeState.color;\n\n                if (i === 0) {\n                    // Set direction for snake head\n                    grid[index].dataset.direction = this.directionMap[snakeState.currentDirection];\n                } else if (i === snakeState.currentPosition.length - 1) {\n                    // Clean up direction for previous snake tail\n                    const previousTailIndex = snakeState.previousPosition[snakeState.previousPosition.length - 1];\n                    delete grid[previousTailIndex].dataset.direction;\n\n                    // Set direction for snake tail\n                    const lastBodyIndex = snakeState.currentPosition[snakeState.currentPosition.length - 2];\n                    grid[index].dataset.direction = grid[lastBodyIndex].dataset.direction;\n                }*/\n            });\n\n            if (frame < frames && snakeState.previousPosition.length > 0) {\n                frame++;\n                requestAnimationFrame(animate);\n            }\n        }\n\n        function drawSnakePart(params) {\n            let x = getX(params);\n            let y = getY(params);\n\n            canvasContext.fillRect(x + params.xFrom, y + params.yFrom, 20, 20);\n            \n            return params;\n        }\n\n        function getCoordinatesFromIndex(index, gridSize) {\n            const x = (index % gridSize) * 20;\n            const y = Math.floor(index / gridSize) * 20;\n            return { x, y };\n        }\n        \n        function getX(params) {\n            let distance = params.xTo - params.xFrom;\n            let steps = frames;\n            let progress = frame;\n\n            return distance / steps * progress;\n        }\n\n        function getY(params) {\n            let distance = params.yTo - params.yFrom;\n            let steps = frames;\n            let progress = frame;\n\n            return distance / steps * progress;\n        }\n    },\n\n    control: function (e, snakeInstance, columns, socket) {\n        if (!snakeInstance.canMove) return;\n\n        if (e.key === this.controlKeys.right && snakeInstance.currentDirection !== -1) {\n            snakeInstance.currentDirection = 1;\n            socket.emit('snake-control', { direction: 'right' });\n        } else if (e.key === this.controlKeys.up && snakeInstance.currentDirection !== columns) {\n            snakeInstance.currentDirection = -columns;\n            socket.emit('snake-control', { direction: 'up' })\n        } else if (e.key === this.controlKeys.left && snakeInstance.currentDirection !== 1) {\n            snakeInstance.currentDirection = -1;\n            socket.emit('snake-control', { direction: 'left' });\n        } else if (e.key === this.controlKeys.down && snakeInstance.currentDirection !== -columns) {\n            snakeInstance.currentDirection = columns;\n            socket.emit('snake-control', { direction: 'down' });\n        }\n    },\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { GameClient } from './GameClient.js';\n\n// Event listeners\ndocument.addEventListener(\"DOMContentLoaded\", function () {\n    const urlParams = new URLSearchParams(window.location.search);\n    const queryParams = Object.fromEntries(urlParams.entries());\n\n    const socket = io('/', {\n        query: queryParams,\n    });\n\n    GameClient.initialize(socket);\n});\n"],"names":[],"sourceRoot":""}