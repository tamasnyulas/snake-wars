import { detailedDiff } from "deep-object-diff";
import { InitialPlayerState } from "@domain/ValueObject/PlayerState";
import GameState, { GameStateName } from "@domain/ValueObject/GameState";
import Player, { PlayerMetadata } from "./Player";
import Container from "typedi";
import CollectibleFactory from "@domain/Service/CollectibleFactory";
import GameEventLoop from "./GameEventLoop";

/**
 * Represents a game entity with properties like game state, players, and game settings.
 */
export default class Game {
    readonly players: { [id: string]: Player } = {};
    readonly state: GameState = new GameState();
    private previousState: GameState | null = null;
    private eventLoop: GameEventLoop;

    constructor(
        public readonly gameId: string,
        public settings: GameSettings,
        private initialPlayerStates: InitialPlayerState[],
        private emitter: (gameId: string, event: string, params: any) => void
    ) {
        this.eventLoop = new GameEventLoop(this);// TODO: need to get rid of the circular dependency
    }

    getInfo (): GameInfo {
        return {
            link: '/game/play?gameId=' + this.gameId, // TODO: the link should be generated by the router
            settings: this.settings,
            numOfPlayers: this.getPlayerCount(),
        };
    }

    getPlayerCount(): number {
        return Object.keys(this.players).length;
    }

    isFull(): boolean {
        return this.getPlayerCount() >= this.settings.numOfPlayers;
    }

    addPlayer(player: Player): void {
        this.players[player.id] = player;

        player.state.setInitialState(this.getUniqueInitialPlayerState());
        this.state.players[player.id] = player.state;
    }

    removePlayer(playerId: string): void {
        this.readdInitialPlayerState(this.players[playerId].state.initialPlayerState);
        delete this.players[playerId];
    }

    hasPlayer(id: string): boolean {
        return !!this.players[id];
    }

    getPlayer(id: string): Player  {
        return this.players[id];
    }

    canStart(): boolean {
        return (this.settings.numOfPlayers == Object.keys(this.players).length && Object.values(this.players).every((player: Player) => player.state.readyCheck));
    }

    startGame() {
        this.resetPlayerStates();
        this.createVirtualGrid();

        this.state.stateName = GameStateName.PLAYING;

        Object.values(this.players).forEach((player: Player, i) => {
            player.state.initialPlayerState!.initialPosition.forEach((position: number) => {
                this.state.grid[position] = i;
            });
        });

        this.state.collectible = Container.get(CollectibleFactory).createOnGrid(this.state.grid);
        this.state.intervalTime = 200; // TODO: move the default value into settings
        this.state.activePlayers = Object.keys(this.state.players).length;

        this.eventLoop.start(this.state.intervalTime);
    }

    endGame(): void {
        console.log('game over');
        this.eventLoop.stop();
        this.state.reset();
        this.previousState = JSON.parse(JSON.stringify(this.state));

        this.emitter(this.gameId, 'end-game', this.state);
    }

    purgeStateDiff(): void {
        const stateClone = JSON.parse(JSON.stringify(this.state));
        const diff = detailedDiff(this.previousState as object, stateClone);
        
        this.previousState = stateClone;
        
        this.emitter(this.gameId, 'sync-state-diff', diff);
    }

    getPlayersMetadata(): PlayerMetadata[] {
        return Object.values(this.players).map((player: Player) => player.getMetadata());
    }

    private getUniqueInitialPlayerState(): InitialPlayerState {
        const initialPlayerState = this.initialPlayerStates.shift();

        if (!initialPlayerState) {
            throw new Error('No initial player state left.');
        }

        return initialPlayerState;
    }

    private readdInitialPlayerState(initialPlayerState: InitialPlayerState | null): void {
        if (initialPlayerState){
            this.initialPlayerStates.unshift(initialPlayerState);
        }
    }

    private resetPlayerStates() {
        Object.values(this.players).forEach((player: Player) => player.resetState());
    }

    private createVirtualGrid() {
        this.state.grid = Array.from({ length: this.settings.columns * this.settings.rows }, (_, i) => 0);
    }
}

export type GameSettings = {
    speedIncrement: number;
    columns: number;
    rows: number;
    numOfPlayers: number;
    endEarly: boolean;
}

export type GameInfo = {
    link: string;
    settings: any; // TODO: fix for the actual settings type
    numOfPlayers: number;
}